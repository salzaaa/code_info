<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Код для справки</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

  <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />

  <link rel="stylesheet" href="style.css">
</head>
<body>

  <h1>Кодик</h1>
  <h2><a href="https://online-compil-py.onrender.com/">тыкк</a> онлайн компилятор</h2>
  <section class="alg">
    <h2>itertools</h2>
    <div class="code_copy">
      <pre><code class="language-python">
itertools.permutations(iterable, r=None) #Генерирует все возможные перестановки элементов из итерируемого объекта длиной r. Если r не указано, используется длина итерируемого объекта.
itertools.combinations(iterable, r) #Генерирует все возможные комбинации элементов из итерируемого объекта длиной r. В отличие от перестановок, порядок элементов в комбинациях не важен.
itertools.combinations_with_replacement(iterable, r) #Генерирует все возможные комбинации элементов из итерируемого объекта длиной r, где элементы могут повторяться
itertools.product(*iterables, repeat=1) #Генерирует декартово произведение входных итерируемых объектов. Это эквивалентно вложенным циклам.
      </code></pre>
      <button class="copy-button">копирка</button>
    </div>
    <div class="info"></div>
  </section>
  <section class="alg">
    <h2>бфс</h2>
    <div class="code_copy">
      <pre><code class="language-python">
from collections import deque

def bfs_adj_matrix(matrix, start):
    n = len(matrix)  
    visited = [False] * n
    queue = deque([start])
    visited[start] = True
    
    while queue:
        vertex = queue.popleft()
        print(vertex, end=" ")  
        
        for neighbor in range(n):
            if matrix[vertex][neighbor] == 1 and not visited[neighbor]:
                visited[neighbor] = True
                queue.append(neighbor)

# Пример матрицы 
matrix = [
    [0, 1, 1, 0],
    [1, 0, 0, 1],
    [1, 0, 0, 1],
    [0, 1, 1, 0]
]

print("BFS:")
bfs_adj_matrix(matrix, 0)  # Начинаем с вершины 0
      </code></pre>
      <button class="copy-button">копирка</button>
    </div>
    <div class="info"></div>
  </section>
  <section class="alg">
    <h2>дфс</h2>
    <div class="code_copy">
      <pre><code class="language-python">
def dfs_iterative_adj_matrix(matrix, start):
n = len(matrix)
visited = [False] * n
stack = [start]

while stack:
    vertex = stack.pop()
    if not visited[vertex]:
        visited[vertex] = True
        print(vertex, end=" ")  # Обработка вершины
        
        # Добавляем соседей в стек (в обратном порядке для правильного порядка обхода)
        for neighbor in reversed(range(n)):
            if matrix[vertex][neighbor] == 1 and not visited[neighbor]:
                stack.append(neighbor)

# Пример использования
print("\nDFS Iterative:")
dfs_iterative_adj_matrix(matrix, 0)

#или
matrix= [
    [1,0,1,0,0,1]
    [1,0,1,0,0,1]
    [0,0,1,0,0,1]
    [1,0,1,0,0,1]
    [0,0,1,0,0,1]
    [0,0,1,0,0,1]

]

def dfs(graph, start, visited=None):
    if visited is None:
        visited = set()
    visited.append(start)

    print(start)

    for next in graph[start] - visited:
        dfs(graph, next, visited)
    return visited

dfs(matrix,0)
      </code></pre>
      <button class="copy-button">копирка</button>
    </div>
    <div class="info"></div>
  </section>
  <section class="alg">
    <h2>матрица кратчайший путь</h2>
    <div class="code_copy">
      <pre><code class="language-python">

from collections import deque

def shortest_path_length(adj_matrix, start_vertex, end_vertex):
    if not adj_matrix or start_vertex < 0 or end_vertex < 0 or start_vertex >= len(adj_matrix) or end_vertex >= len(adj_matrix):
        return -1

    queue = deque()
    queue.append(start_vertex)

    distances = [-1] * len(adj_matrix)
    distances[start_vertex] = 0  # Расстояние от начальной вершины до самой себя равно 0

    # BFS
    while queue:
        current_vertex = queue.popleft()

        if current_vertex == end_vertex:
            return distances[current_vertex]

        for neighbor in range(len(adj_matrix)):
            if adj_matrix[current_vertex][neighbor] == 1 and distances[neighbor] == -1:
                # Если сосед ещё не посещён, добавляем его в очередь и обновляем расстояние
                distances[neighbor] = distances[current_vertex] + 1
                queue.append(neighbor)

    return -1


if __name__ == "__main__":
    # Пример матрицы смежности
    adj_matrix = [
        [0, 1, 0, 0],
        [1, 0, 1, 1],
        [0, 1, 0, 1],
        [0, 1, 1, 0]
    ]

    result = shortest_path_length(adj_matrix, 0, 3)
    print(f"Длина кратчайшего пути: {result}")

      #перевод строки списка в число
      i = ['1,0,0,1,0,']
      int_list = [int(item) for item in i.split(',') if item]
      print(int_list)
      </code></pre>
      <button class="copy-button">копирка</button>
    </div>
    <div class="info"></div>
  </section>

  
  <section class="alg">
    <h2>os math numpy sympy</h2>
    <div class="code_copy">
      <pre><code class="language-python">
import sympy
sympy.isprime() #проверка на простоту
import os
os.listdir(folder)#получение других папок в папаке

import math
print(math.lcm(2 числа)) #НОК
print(math.gcd(2 числа)) #НОД
print(math.comb(количество объектов,по сколько штук))

import numpy as n
n.cbrt() #кубический корень
#конвертавция датафреймва в нампай данные а потом в список
data=data.values
data=data.tolist()
        
      </code></pre>
      <button class="copy-button">копирка</button>
    </div>
    <div class="info"></div>
  </section>
  <section class="alg">
    <h2>справка</h2>
    <div class="code_copy">
      <pre><code class="language-python">
#сортировка словаря по значениям 
sorted = dict(sorted(rooms.items(), key=lambda item: item[1]))

      </code></pre>
      <button class="copy-button">копирка</button>
    </div>
    <div class="info"></div>
  </section>




  <script>
    document.querySelectorAll('.copy-button').forEach(button => {
      button.addEventListener('click', () => {
        const codeBlock = button.previousElementSibling.querySelector('code');
        const code = codeBlock.textContent;

        navigator.clipboard.writeText(code).then(() => {
          alert('Code copied to clipboard!');
        }).catch(err => {
          console.error('Failed to copy code: ', err);
        });
      });
    });
  </script>



</body>
</html>
